import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

const initialState = {
  empty: true,
  numOfItems: [],
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const incrementAsync = createAsyncThunk(
  "cart/getItems",
  async (amount) => {
    const response = await fetchCount(amount);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const cartSlice = createSlice({
  name: "cart",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.numOfItems += 1;
    },
    addToCart: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    removeFromCart: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1;
    },
    decrement: (state) => {
      state.numOfItems -= 1;
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    clear: () => {
      return { ...initialState };
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = "loading";
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = "idle";
  //       state.value += action.payload;
  //     });
  // },
});

export const { increment, decrement, removeFromCart, addToCart, clear } =
  cartSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectIncrement = (state) => state.cart.increment;
export const selectDecrement = (state) => state.cart.decrement;
export const selectClear = (state) => state.cart.clear;
export const selectAddToCart = (state) => state.cart.addToCart;
export const selectRemoveFromCart = (state) => state.cart.removeFromCart;
// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd = (amount) => (dispatch, getState) => {
  const currentValue = selectCount(getState());
  if (currentValue % 2 === 1) {
    dispatch(incrementByAmount(amount));
  }
};

export default counterSlice.reducer;

// import React, { useReducer } from "react";
// import CartContext from "./CartContext";
// import CartReducer from "./CartReducer";
// import { sumItems } from "./CartReducer";

// const storage = localStorage.getItem("items")
//   ? JSON.parse(localStorage.getItem("items"))
//   : [];

// const cartState = ({ children }) => {
//   const initialState = {
//     items: storage,
//     ...sumItems(storage),
//     count: 1,
//     checkout: false,
//   };

//   // reducers
//   const [state, dispatch] = useReducer(CartReducer, initialState);

//   const addToCart = (payload) => {
//     dispatch({ type: "ADD_TO_CART", payload: payload });
//   };

//   const clearCart = () => {
//     dispatch({ type: "CLEAR" });
//   };

//   const removeFromCart = (payload) => {
//     dispatch({ type: "REMOVE_ITEM", payload: payload });
//   };

//   const increase = (payload) => {
//     dispatch({ type: "INCREASE", payload: payload });
//   };

//   const decrease = (payload) => {
//     dispatch({ type: "DECREASE", payload: payload });
//   };
//   const increment = (payload) => {
//     dispatch({ type: "INCREMENT", payload: payload });
//   };
//   const decrement = (payload) => {
//     dispatch({ type: "DECREMENT", payload: payload });
//   };

//   return (
//     <CartContext.Provider
//       value={{
//         showCart: state.showCart,
//         items: state.items,
//         count: state.count,
//         addToCart,
//         removeFromCart,
//         increase,
//         decrease,
//         increment,
//         decrement,
//         clearCart,
//         ...state,
//       }}
//     >
//       {children}
//     </CartContext.Provider>
//   );
// };

// export default cartState;

// import {
//     ADD_TO_CART,
//     REMOVE_ITEM,
//     DECREMENT,
//     INCREMENT,
//     CLEAR,
//   } from "./cartTypes";

//   // local storage
//   const Storage = (items) => {
//     localStorage.setItem("items", JSON.stringify(items.length > 0 ? items : []));
//   };

//   // handles how items are added up
//   export const sumItems = (items) => {
//     Storage(items);
//     let itemCount = items.reduce((total, product) => total + product.quantity, 0);

//     let total = items
//       .reduce((total, product) => total + product.price * product.quantity, 0)
//       .toFixed(2);

//     return { itemCount, total };
//   };

//   const cartReducer = (state, action) => {
//     switch (action.type) {
//       case ADD_TO_CART: {
//         const item = state.items.find((item) => item.id === action.payload.id);

//         if (!item) {
//           state.items.push({
//             ...action.payload,
//             quantity: state.count,
//           });
//         } else {
//           return {
//             ...state,
//             items: state.items.map((item) =>
//               item.id === action.payload.id
//                 ? {
//                     ...item,
//                     quantity: state.count,
//                   }
//                 : item
//             ),
//           };
//         }
//         Storage(state.items);

//         return {
//           ...state,
//           ...sumItems(state.items),
//           items: [...state.items],
//         };
//       }

//       case REMOVE_ITEM:
//         return {
//           ...state,
//           count: state.count,
//           ...sumItems(
//             state.items.filter((item) => item.id !== action.payload.id)
//           ),
//           items: [...state.items.filter((item) => item.id !== action.payload.id)],
//         };

//       case CLEAR:
//         return {
//           items: [],
//           count: 1,
//           ...sumItems([]),
//         };

//       case INCREMENT:
//         return {
//           ...state,
//           count: state.count + 1,
//         };

//       case DECREMENT:
//         if (state.count <= 0) {
//           return {
//             ...state,
//             count: 0,
//           };
//         } else {
//           return {
//             ...state,
//             count: state.count - 1,
//           };
//         }

//       default:
//         return state;
//     }
//   };

//   export default cartReducer;
